/*
The table below describes the required computations and their dependencies

No. | Dependency | Computation method | Result
----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
1.  |            | given              | sk = 68b39a809d6a009d76593c26d4b897acfd34d40b2fa9639df4605a1317d3448e
2.  |            | given              | timestamp = 1553702123276
3.  |            | lastNonce          | nonce = 9223372036854775807
4.  | 1,         | ed25519            | pk = da19138c71db4010e791f40cbf73fb1e5dda989a8f3f5bca83f324b6529c5869
5.  | 4, 2,      | genIds             | uname = Unforgeable(0xbfda50b15aad23c8261201d791e43b1eee2454ba13c68e4c7e2cb3b722732058)
6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xbfda50b15aad23c8261201d791e43b1eee2454ba13c68e4c7e2cb3b722732058) })
7.  | 6,         | protobuf           | toSign = 2a3eaa013b0a0d2a0b10feffffffffffffffff010a2a5a280a243a220a20bfda50b15aad23c8261201d791e43b1eee2454ba13c68e4c7e2cb3b7227320581001
8.  | 7, 1,      | ed25519            | sig = dddd311ebd975d6d1b3c7a08c0a4d54167c716c1a4051297f601e20b1cce423061d6cf7bc6d48df4227e1f8428559e18ecc27fc1180c9fb35a9c7d90f20e2901
9.  | 4,         | registry           | uri = rho:id:w6koqnba5yr3f9hmtckihj4mj6q6wtre48w5j3n6nd314zwogyfmuf
----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
*/

new MakePoS,
    rs(`rho:registry:insertSigned:ed25519`),
    stdout(`rho:io:stdout`),
    uriOut in {
    contract MakePoS (@minimumBond, @maximumBond, @initialBonds, return) = {

        match "11112GofKy1v5mPWZjZEYBByvpZ4ahYJp6vFN1hgGCn7L543rFSpyA".hexToBytes() {

            posRevAddress => {

                new eitherCh,
                    revVaultCh,
                    listCh,
                    registryLookup(`rho:registry:lookup`) in {

                    registryLookup!(`rho:id:j6trahbxycumerwpr5qype7j43b7eqh8auebwsa9nn68if47gswh73`, *eitherCh)
                    | registryLookup!(`rho:id:1o93uitkrjfubh43jt19owanuezhntag5wh74c6ur5feuotpi73q8z`, *revVaultCh)
                    | for (@(_, Either) <- eitherCh; @(_, RevVault) <- revVaultCh; @(_, ListOps) <- listCh) {

                        new bondsCh,
                            this,
                            getParameters(`rho:deploy:params`),
                            revAddressOps(`rho:rev:address`),
                            paymentStore,
                            deposit in {

                            bondsCh!(initialBonds)

                            | contract this (@"getBonds", return) = {
                                for(@bonds <- bondsCh) {
                                    bondsCh!(bonds) | return!(bonds)
                                }
                            }

                            // TODO: Validate that the associated wallet comes from the same mint as the purse
                            // TODO: Can we assume at this point that [[@pk]] is a valid public key?
                            | contract this (@"bond", @bondAmount, @sigVerify, return) = {

                                new bondResultCh,
                                    isBonded,
                                    validateBondAmount,
                                    validateBondingRate,
                                    validatePublicKey,
                                    updateBonds,
                                    parametersCh in {

                                    @Either!(
                                        "compose",
                                        bondAmount,
                                        [*validateBondAmount,
                                        *validateBondingRate,
                                        *validatePublicKey,
                                        *deposit,
                                        *updateBonds],
                                        *return
                                    )

                                    | contract isBonded (@userPk, return) = {
                                        for(@bonds <- bondsCh) {
                                            bondsCh!(bonds) | return!(bonds.contains(userPk))
                                        }
                                    }

                                    | contract validateBondAmount (@bondAmount, return) = {
                                        if (bondAmount < minimumBond) {
                                            return!((false, "Bond less than minimum!"))
                                        } else if (bondAmount > maximumBond) {
                                            return!((false, "Bond greater than maximum!"))
                                        } else {
                                            return!((true, bondAmount))
                                        }
                                    }

                                    // TODO: figure out rate-limiting of bonding
                                    | contract validateBondingRate (@bondAmount, return) = {
                                        return!((true, bondAmount))
                                    }

                                    | contract validatePublicKey (@bondAmount, return) = {
                                        new isBondedCh, parametersCh in {
                                            getParameters!(*parametersCh)
                                            | for (_, _, @userPk, _ <- parametersCh) {
                                                isBonded!(userPk, *isBondedCh)
                                                | for (@isBondedResult <- isBondedCh) {
                                                    if (isBondedResult) {
                                                        return!((false, "Public key ${pk} already bonded." %% {"pk" : userPk}))
                                                    } else return!((true, bondAmount))
                                                }
                                            }
                                        }
                                    }

                                    | contract updateBonds (@bondAmount, return) = {
                                        new parametersCh in {
                                            getParameters!(*parametersCh)
                                            | for(@bonds <- bondsCh; _, _, @userPk, _ <- parametersCh) {
                                                bondsCh!(
                                                    bonds.set(
                                                        userPk,
                                                        [bondAmount, sigVerify, bonds.size() + 1]
                                                    )
                                                ) | return!((true, "Bond successful!"))
                                            }
                                        }
                                    }
                                }
                            }

                            //Assuming that user public key is valid, a vault should always be returned.
                            | contract deposit (@amount, return) = {
                                new parametersCh,
                                    vaultCh,
                                    revAddressCh in {
                                    getParameters!(*parametersCh)
                                    | for (_, _, @userPk, _ <- parametersCh) {
                                        revAddressOps!("fromPublicKey", userPk, *revAddressCh)
                                        | for (@revAddress <- revAddressCh) {
                                            @RevVault!("findOrCreate", revAddress, *vaultCh)
                                            | for (@(true, vault) <- vaultCh) {
                                                @vault!("transfer", posRevAddress, amount, *return)
                                            }
                                        }
                                    }
                                }
                            }

                            | paymentStore!([Nil, Nil, Nil, Nil])

                            //Make it easy to query the last payment so that validators
                            //can check how much phlo there is for the deploy.
                            | contract this(@"lastPayment", return) = {
                                for(@payment <- paymentStore) {
                                    paymentStore!(payment) | return!(payment)
                                }
                            }

                            | contract this (@"pay", @amount, return) = {
                                new parametersCh, depositRet in {
                                    deposit!(amount, *depositRet)
                                    | getParameters!(*parametersCh)
                                    | for (@depositResult <- depositRet; @codeHash, @phloRate, @userPk, @timestamp <- parametersCh; lastPayment <- paymentStore) {
                                        match depositResult {
                                            (true, Nil) => { paymentStore!([codeHash, userPk, timestamp, phloRate * amount]) | return!(phloRate *amount) }
                                            (false, err) => { paymentStore!([codeHash, userPk, timestamp, 0]) | return!(0) }
                                        }
                                    }
                                }
                            }

                            | return!(bundle+{*this})
                        }
                    }
                }
            }
        }
    } |

  rs!(
    "da19138c71db4010e791f40cbf73fb1e5dda989a8f3f5bca83f324b6529c5869".hexToBytes(),
    (9223372036854775807, bundle+{*MakePoS}),
    "dddd311ebd975d6d1b3c7a08c0a4d54167c716c1a4051297f601e20b1cce423061d6cf7bc6d48df4227e1f8428559e18ecc27fc1180c9fb35a9c7d90f20e2901".hexToBytes(),
    *uriOut
  ) |
  
  for (@uri <- uriOut) {
    stdout!("Pos ${unforgeableName} was registered at URI ${uri}" %% {"unforgeableName": *MakePoS, "uri": uri})
  }
}
